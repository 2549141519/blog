点击返回[🔗我的博客文章目录](https://2549141519.github.io/#/toc)
* 目录
{:toc}
<div onclick="window.scrollTo({top:0,behavior:'smooth'});" style="background-color:white;position:fixed;bottom:20px;right:40px;padding:10px 10px 5px 10px;cursor:pointer;z-index:10;border-radius:13%;box-shadow:0.5px 3px 7px rgba(0,0,0,0.3);"><img src="https://2549141519.github.io/blogImg/backTop.png" alt="TOP" style="background-color:white;width:30px;"></div>

paper [link](https://www.microsoft.com/en-us/research/uploads/prod/2016/12/paxos-simple-Copy.pdf)  
# 1. Paxos算法介绍
Paxos 是一种用于 分布式系统 中达成一致性的算法，通常用于解决分布式系统中的 共识问题。它保证了即使在系统中的某些节点出现故障时，多个节点也能就某个值或状态达成一致。Paxos 主要用于在没有中央协调者的系统中确保数据的 一致性 和 可靠性。  

Paxos的工作流程可以分为三个主要角色和三个阶段。  

## 1.1 三个主要角色
```
1. Proposer：提议者，负责生成提议值，并发送提议消息给Acceptor，建议某个值成为共识值。  
2. Acceptor：接受者，负责接收和存储提议。多数 Acceptor 接受提议后，该提议才能生效。  
3. Learner：学习者，负责接收Acceptor的响应，学习最终达成的共识结果。  
```  

## 1.2 三个阶段
```
1. Prepare 阶段：
提议者向接受者发送提议，要求 Acceptor 表示是否愿意接受更高编号的提议。
2. Promise 阶段：
Acceptor 向 Proposer 承诺不会接受编号低于当前提议的其他提议。
3. Accept 阶段：
一旦提议获得大多数 Acceptor 的同意，Proposer 就可以宣布该提议通过，Learner 将会学习到最终的共识值。
```   

## 1.3 Paxos的关键特性
容错性：  
即使部分节点故障（如网络分区或节点崩溃），Paxos 仍然可以正常工作，只要大多数节点（一般为超过半数的 Acceptor）正常工作。  

一致性：  
所有节点最终都会达成一致的共识值，保证系统不会出现不同步的情况。  

可恢复性：  
即使系统发生故障，恢复后 Paxos 仍能继续从上次中断的地方继续运行，不会丢失已经达成的共识。  

# 2. 一致性算法
一致性算法是Paxos的核心。目的是在多个进程中达成一致选择某个值（即 共识），并提出了实现这种共识的 安全性要求。    

## 2.1 共识问题的基本目标
共识算法的目标是确保在一组提议的值中，选择一个并让系统内的所有进程知道这个被选择的值。具体要求包括：  
```
如果没有提出任何值，那么不应选择任何值。
如果已经选择了一个值，那么系统内的进程能够学习到这个被选择的值。
```  

## 2.2 安全性要求
共识算法必须遵循以下 安全性要求：   
```
只能选择已提议的值：
算法不能凭空选出一个没有被任何进程提议的值。
只能选择单个值：
即使有多个进程提出了不同的值，最终系统内只能有一个值被选择。
只有在某个值实际被选中后，进程才能得知这个值：
进程不能错误地认为一个值被选中了，除非这个值确实已经被选择。
```  

## 2.3 活性要求
虽然问题中没有精确描述活性要求，但提出了如下目标：  
```
某个提议的值最终应被选择：
如果有进程提出了值，算法应该保证最终会选择某个值，而不是无限期等待。
被选中的值应该能够被进程学习到：
一旦某个值被选中，系统中的进程应能最终得知这个被选中的值。
```  

## 2.4 通信模型
系统中的代理（即提议者、接受者、学习者）之间通过 消息 通信，问题假设使用的是典型的 异步、非拜占庭模型，其特性包括：  
```
异步执行：
代理的操作速度可以任意，可能会失效（崩溃）并重启。
崩溃恢复：
所有代理可能在值被选中后崩溃并重启，因此，系统必须记住一些信息，以便在重启后继续运行。否则，在没有任何信息恢复的情况下，算法是无法继续工作的。
消息的不确定性：
消息可能延迟、丢失、重复发送，但消息内容不会被篡改（即没有拜占庭错误）。
```  

## 2.5 工作原理
Paxos 算法被设计为在多个节点可能失效或消息丢失的情况下，仍然能够在这些节点之间达成共识。  

### 2.5.1 初始方案：单个接受者
最简单的方案是只有一个 接受者（Acceptor），每当一个 提议者（Proposer） 提出值时，接受者会选择第一个接收到的提议值。然而，这个方案有明显的缺点：如果接受者失败，系统将无法继续前进。  

### 2.5.2 改进方案：多个接受者
为了提高容错性，可以使用多个接受者。提议者会向一组接受者发送提议，提议值会在足够多的接受者接受后被认为是“选择的值”。“足够多”通常意味着多数接受者，这样可以确保至少有一个接受者在两个不同的多数集合中（即保证交集），从而保证不会有两个不同的值被同时选中。  

### 2.5.3 避免冲突：引入提议编号
为了避免多个提议同时被不同的接受者接受，导致没有单一的多数值被选中，Paxos 引入了 提议编号。提议不仅包含一个值，还包含一个唯一的编号。编号确保提议的先后顺序，并规定较高编号的提议具有优先权。  

### 2.5.4 安全性保证：P2性质
为了确保共识算法的安全性，必须保证如果一个值 `v` 已经被选中，那么所有编号更高的提议也必须选择相同的值 `v`。这一点是通过“P2 性质”来保证的，P2 确保选中值后，后续的提议不会违反已经达成的共识。  

### 2.5.5 P2 性质的推导和扩展
为了实现 [P2](#27-p2)，系统需要满足以下约束：`当提议者发送新的提议时，它必须先确保没有较高编号的提议已经被接受。`这是通过发送 准备请求（prepare request） 来实现的，提议者要求接受者承诺不再接受任何比当前提议编号更低的提议，并报告其已接受的最高编号提议。基于这些信息，提议者可以确保新提议符合 P2 性质。   

### 2.5.6 算法两个阶段
第一阶段：  
提议者选择一个提议编号，并向多数接受者发送准备请求，要求接受者承诺不再接受任何比该编号低的提议，并返回已接受的最高编号提议（如果有）。  
第二阶段：  
如果提议者从多数接受者那里得到了响应，它会选择一个值，并向接受者发送 接受请求（accept request），要求接受者接受这个编号的提议。如果提议符合条件，接受者会接受该提议。  

### 2.5.7 提议放弃与优化
提议者可以在任意时间放弃提议，并且算法允许接受者忽略已经过时的准备请求或接受请求。如果接受者发现自己已经响应了更高编号的提议，则会忽略较低编号的提议。提议者也可以在发现有更高编号的提议正在进行时放弃当前提议，以提高算法效率。  

### 2.5.8 数据持久性和容错
为了应对节点崩溃或重启，Paxos 要求每个接受者记住它曾经响应过的最高编号提议和接受过的最高编号提议。这样，即使接受者重新启动，算法的安全性依然能够得到保证。  

## 2.6 学习者（Learner） 如何得知某个值已经被选择
核心问题是学习者如何从 接受者（Acceptor） 那里获悉被选中的提议（即被选中的值）。有几种方法可以实现这一点，分别在可靠性和通信开销之间做出了权衡。  

### 2.6.1 简单算法：每个接受者通知所有学习者
每当一个接受者接受了一个提议，它就通知所有的学习者该提议的信息。这种方式可以让学习者尽早知道被选中的值，但它的代价是通信开销非常大。接受者必须给每个学习者发送消息，消息的总数为 接受者数量 与 学习者数量 的乘积。这在规模较大的系统中通信开销会非常高。  

### 2.6.2 优化方法：引入“特定学习者”
为了降低通信开销，可以引入一个“特定学习者（distinguished learner）”，所有接受者在接受提议后只通知这个特定的学习者。然后，特定学习者将被选中的值通知给其他学习者。这种方法减少了通信量，消息总数只等于 接受者数量 和 学习者数量 的总和。然而，这种方法增加了可靠性风险——如果特定学习者出现故障，系统就无法继续工作。   

### 2.6.3 改进方法：使用多个特定学习者
为了提高系统的可靠性，可以使用多个特定学习者。每个接受者向这些特定学习者发送信息，然后这些特定学习者将值广播给其他学习者。这种方法在保持通信开销相对较低的同时提高了系统的容错性，因为即使一个特定学习者失败，其他特定学习者仍然可以通知学习者被选中的值。不过，增加特定学习者的数量也会提高通信复杂度。  

### 2.6.4 消息丢失的处理
由于 Paxos 是异步系统，消息可能丢失，导致一个值已经被选中但学习者却不知道。这种情况下，学习者可以向接受者询问他们接受的提议。但如果接受者出现故障，学习者可能无法得知多数接受者是否接受了某个提议。  

### 2.6.5 提议者的作用
如果学习者需要确切地知道是否有值被选中，它可以要求提议者发起一个新的提议。这样，即使当前没有学习到选定值，通过发起新的提议，学习者最终也能通过新的提议得知系统的共识。  

## 2.7 P2
在 Paxos 算法中，P2 性质 是保证算法安全性的重要条件。P2 性质的目的是确保一旦某个值 `v` 被选中后，所有将来被选中的提议（无论提议的编号如何）都必须具有相同的值 `v`，从而避免系统选出多个不同的值。  

P2 性质 规定：如果一个编号为 `m` 的提议的值 `v` 被选中，那么所有编号大于` m `的提议如果被选中，它们的值也必须是` v`。  

这一性质可以保证 Paxos 算法的安全性，即使有多个提议者并行发起不同的提议，最终选中的值也不会出现冲突。  

### 2.7.1 P2 性质的意义
通过 P2 性质的约束，可以确保：  
```
一旦某个值被多数接受者接受，那么所有后续的提议必须选择同一个值。
不会有两个不同的值被不同的提议者选中。
```  

### 2.7.2 P2 性质的实现
```
在发出提议之前，提议者（Proposer） 需要向多数接受者（Acceptor）发送一个 准备请求（prepare request），询问他们已经接受的最高编号的提议。
如果有接受者已经接受了某个编号较小的提议（例如，编号 m 的提议），那么提议者在发出新的提议时，必须使用已经被接受的编号 m 对应的值，而不能提出新的值。
如果没有任何接受者接受过编号小于当前提议编号的提议，那么提议者可以自由选择一个新的值。
```   

## 2.8 Paxos 算法 中如何确保 进展性（liveness）
在 Paxos 算法中，如果存在多个提议者（proposer），这些提议者可能会同时发起不同编号的提议。这样可能导致一个 活锁 场景：两个提议者不断地增加提议编号，但没有任何一个提议能被最终选中。具体过程如下：  
1. 提议者 p 完成了编号为 n1 的第一阶段（Phase 1）。  
2. 提议者 q 然后完成了编号为 n2 > n1 的第一阶段，所有接受者（acceptor）现在都承诺不再接受任何编号小于 n2 的提议。  
3. 当提议者 p 进入第二阶段并发送编号为 n1 的接受请求时，所有请求都被忽略，因为接受者已经承诺接受 n2 及更大的提议。  
4. 提议者 p 重新开始，并完成了编号为 n3 > n2 的新一轮提议，导致提议者 q 的编号为 n2 的第二阶段请求被忽略。  

### 2.8.1 解决方案
为了解决这一问题，Paxos 算法需要选出一个 特定提议者（distinguished proposer），即在特定时刻只有一个提议者能够发起提议。  
关键点：  
```
如果这个特定提议者可以与多数接受者成功通信，并且使用一个大于任何已使用提议编号的新编号，那么它的提议将会成功被接受。
如果提议者得知有编号更高的提议，它会放弃当前的提议，重新发起编号更高的提议，直到成功。
```  

进展性依赖于系统中以下条件的正常工作：  
```
提议者：需要有一个被选中的提议者来主导提议过程。
接受者：接受者必须能够与特定提议者正常通信。
网络通信：通信网络不能完全失效，消息必须能够在一定时间内传递。
```  

为了选出一个“特定提议者”，系统可能需要使用随机性或基于真实时间的机制，比如使用 超时（timeout） 机制来决定哪个提议者能够主导提议过程。  

## 2.9 Paxos 算法 的实现

### 2.9.1 基本网络模型
Paxos 算法假设在一个 分布式网络 中有多个进程。每个进程在 Paxos 中可以扮演多个角色，包括：提议者、接受者、学习者。  
在实现中，Paxos 通过一个被选出的 领导者（Leader） 来扮演关键角色。领导者不仅是 特定提议者（distinguished proposer），还负责扮演 特定学习者（distinguished learner） 的角色。  

### 2.9.2 消息通信机制
Paxos 算法的通信基于普通的消息传递。在实际实现中，提议者、接受者、学习者之间通过发送和接收消息进行交互：  
每条消息都会附带相应的 提议编号，这样可以防止不同提议者的消息被混淆，确保提议编号的唯一性和顺序性。  

### 2.9.3 稳定存储的使用
稳定存储（Stable storage） 是 Paxos 算法的关键部分之一，保证了在系统发生故障或节点重启的情况下，系统依然可以恢复之前的状态：    
每个接受者在发送响应消息之前，会将其打算发送的响应信息记录在稳定存储中。这样即使系统发生故障，重启后接受者可以恢复并继续工作，不会丢失已经接受的提议信息。  

### 2.9.4 提议编号的唯一性
Paxos 通过 唯一编号的提议 来避免冲突，即每个提议必须有一个唯一的编号，不能出现两个提议者发出相同编号的提议。为了实现这一点：  
不同的提议者选择提议编号时，使用 不同的编号集合，确保每个提议者的提议编号不重叠。例如，提议者 A 可能从编号集合 `{1, 4, 7, 10...}` 选择，而提议者 B 则从集合` {2, 5, 8, 11...} `中选择。  
每个提议者会在稳定存储中记录其曾经尝试发出的 最高编号提议。在开始新的提议时，提议者会选择一个比之前编号更大的编号，从而避免重复编号。  

### 2.9.5 阶段 1 的启动
在 Paxos 的 阶段 1中，提议者发出准备请求（prepare request）以获取多数接受者的承诺。提议者会使用比之前尝试的提议编号更大的编号来启动这个阶段，确保提议的编号是唯一的并且不会与过去的提议冲突。  

# 3. 分布式状态机（distributed state machine）

## 3.1 分布式状态机的基本概念
一个简单的分布式系统可以被看作是多个客户端向一个中央服务器发出命令，而这个服务器执行这些命令并更新其状态。服务器可以被描述为一个 确定性状态机（deterministic state machine）：    
```
状态机具有当前的状态，通过执行命令生成新的状态和输出。例如，在一个银行系统中，状态可以是用户的账户余额，命令可以是提款或存款操作。
```  
如果使用单个中央服务器，它的故障将导致整个系统失效。因此，实际实现中使用多个服务器来独立地实现状态机，并通过 Paxos 算法确保这些服务器都执行相同的命令序列。  

## 3.2 状态机与 Paxos 算法
为了保证所有服务器执行相同的命令序列，系统为每个状态机命令运行一轮 Paxos 算法的实例。例如，第 i 个状态机命令是通过第 i 次 Paxos 共识算法实例决定的。所有服务器在 Paxos 算法中扮演提议者、接受者和学习者的角色，保证每个命令都能被最终确定。  

## 3.3 领导者的选举和命令执行
在正常操作中，一个服务器会被选为 领导者（leader），它作为唯一的提议者来发布客户端的命令。领导者决定每个命令在命令序列中的位置，并尝试通过 Paxos 算法确保命令被选中。例如，如果领导者决定某个命令是第 135 个命令，它会尝试让该命令成为第 135 次 Paxos 实例中的被选中值。  

领导者通常能成功，但在某些情况下可能失败，例如其他服务器也认为自己是领导者并试图为相同位置发布不同的命令。然而，Paxos 算法保证在相同位置上最多只有一个命令能被选中。  

## 3.4 Paxos 的效率
提议的值直到 第二阶段才被确定。在提议者完成第一阶段后，提议者可以选择根据已有的值进行提议，或者自由选择一个新值。领导者通常会在执行了某个阶段 1 后快速进入阶段 2，确保命令能被快速确定。  

## 3.5 系统故障和领导者切换
当领导者故障时，新领导者会被选举出来。新领导者需要从之前的 Paxos 实例中学习已经确定的命令，并从尚未选中的命令序列中开始提议新的值。例如，如果新领导者知道命令 1–134 和 138、139 已被选中，它会在 135–137 和 140 之后的实例中执行第一阶段，以确保这些位置的命令被填补。  

在处理命令缺口时，领导者可以选择用 “空操作（noop）” 来填补，这不会改变系统状态。这样可以确保系统的命令序列没有空隙，后续命令可以继续执行。  

## 3.6 提议和响应
领导者可以在它的某个命令还未被确认选中时继续提议下一个命令。即使有些消息丢失，Paxos 算法也能通过消息重传来确保命令最终被选中。然而，如果领导者故障，可能会留下一些命令缺口，新领导者上任时需要填补这些缺口。  

## 3.7 系统的扩展性和重配置
如果系统中的服务器集合需要改变，可以将服务器信息作为状态的一部分，通过状态机命令来更新。在执行第 i 个命令后，新的服务器集合可以被指定为处理第 i+α 个命令的服务器集合，这使得系统能够灵活地进行重新配置。